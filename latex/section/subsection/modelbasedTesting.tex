\subsection{Model-based testing}

Modelbased testing makes traditional unit tests applicable for self-adaptive systems by generating tests automatically. The idea of model-based testing is not to think of all different scenarios and writing tests to each test-case oneself, but to generate these tests based on a model of the system. The target of generating tests for SAS is to cover all available scenarios and to test every situation the SAS might be in.

\subsubsection{Finding failure scenarios}

To find failure scenarios there is the need for searching for aspects that can fail during execution. P\"uschel et al. \cite{puschel2013towards} define them refering to Figure~\ref{failures}. The different failure scenarios are:

\begin{itemize}
  \item SENS: misinterpreted sensor data
  \item TRIG: misinterpreted event
  \item PRE: misinterpreted model
  \item ADAPT: wrong adaptation derived
  \item PLAN: inconsistent planning
  \item SCHED: inconsistent scheduler
  \item POST: corrupt model construction
  \item RECONF: reconfiguration failure
  \item EVENT: wrong event creation
  \item EFFECT: processing wrong effect production
\end{itemize}

\subsubsection{Modelling of behavior}

The next step is to model the behavior of the SAS. Therefore it is useful to look at all the failure scenarios and derive some behavior models from that. Models could for example be some state-flow charts that show which state should follow after a certain state. Especially interesting now are state-flows that seem to be orthogonal. 

An example of how this could look like was made by P\"uschel et al. in \cite{puschel2014black}.

\subsubsection{Testing}

After modelling different orthogonal state-flows or other behavior models, the test-suite will do the rest of the work: generating test-cases. This is done by merging the models together canonically and getting a huge set of test scenarios. For each of these test scenarios there will be one separate test. The great benefit is that the test engineer does not need to think of every scenario. When the behavior is modeled, the test-suite will generate every single test scenario that can be derived from the models. So if there is a test-case that is very unlikely to happen, the testing engineer might leave it out or does not even think about it. But with this method it is tested anyway. If the system then gets to this unlikely state it will be prepared because the scenario was handled during testing already.